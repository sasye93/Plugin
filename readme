requirements:
- package structure must fit to folder structure, e.g. package.sub.class1 must be inside package/sub/
- entry points must have same name as peer an be inside same package, but not nested in class, e.g. entry point of package.sub.parentClass$PeerClass must be package.sub.PeerClass
- build.sbt: add retrieveManaged := true; path must be standard lib_managed
- requires at least scala 2.10 (reflection API)


for windows contianres: experimental on


warning when multiple peer starts in 1 entry point (one service per container)
entry point check as attribute active
temp dir nich in classes, kommt durcheinander,

requirements: cygwin64 or anything for shell support

You need the following ports open to traffic to and from each Docker host participating on an overlay network:

TCP port 2377 for cluster management communications
TCP and UDP port 7946 for communication among nodes
UDP port 4789 for overlay network traffic

//////////
monitoring: docker stats; images; prometheus?; logs
https://code-maze.com/top-docker-monitoring-tools/

hmm, error is thrown (blackbox/blackbox not in compiler mirror) if not reflect included in target project

you could use a top level peer class, to create interface points where everyone connect!!!

unable to prepare context: unable to evaluate symlinks in Dockerfile path: Das System kann den angegebenen Pfad nicht finden. (126): file path too long!
service names max 63 chars, so no extremely long package paths, name is module fullname + ep full name, so. + second package cutted, so ep name must be unique without package identifier.

script in container must have unix ending !

err inspect:
docker service ps --no-trunc {serviceName}

// volumes are not multi host fähig, local treiber, aber es gibt keinen...

//// known bugs
#7178 https://github.com/scala/scala/pull/7178
 fixed in 2.13
 => no recursive call of object inside function/constructor, so resolveIp(Client) must be done above and then referred inside.
only primitives in calls
 all or no ports published, as services size should be small anyway, and sep of concerns

 swarm services are not  attachable, in normal containers with -i you can docker attach xxx and directly use stdin for process
 name must be unique; but containers can also communicate via --alias, so --alias must containt the name resolved via resolveIp, nut necessraly name.

 cred should be stored in docker cred helper / store (hint in schrift)
 common failure is running out of memory, makes services/containers shuitdown wihtout notice or log entry or anything all the time

 libs must be copied because they must be inside docekr context

 low ports crush container??, recommended: 32768 to 61000

 in @ config """ strings, no .stripMargin!

 nach wie vor problem: keine mehrere main methoden (allg gleiche methoden)

 if your code is statefull, container or service with replica one => maybe as parameter with automatic replica=1 or something?

 >
 docker secrets, describe how works

 services should not terminate in success cases (multitier.terminate)
 ports in gateway angabe => merken dass nur ports innerhalb erkannt werden, z.b. gateway ports für http die ausserhalb geöffnet werden müssen explizit

 beispoiele, case study beschreiben, how to run.
 directory structure of ouput beschreiben

 what one could do netxt:
 - automatic Tools ip modification
 - build helper for scaling`?

 error connection is closing --> restart docker
 multiple is not really necessary any more, or? actually only for dynamic stuff
 one should work with optional ties where possible, fault tolerance!

 overflow err: no circular dependencies also, eg in 2 start objects
 - container vorteil: no need to worry about startup order, bec just redeploys when con fail